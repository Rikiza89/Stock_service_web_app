# stock_service/views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.contrib import messages
from django.db import transaction
from django.utils.translation import gettext_lazy as _
from django.urls import reverse
from django.db.models import Sum, F, ExpressionWrapper, fields
from datetime import date, timedelta
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.views.generic import ListView, CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy

from .forms import (
    SocietyRegistrationForm, CustomAuthenticationForm, StockObjectForm,
    StockMovementForm, StockUsageForm, RefillScheduleForm,
    DrawerForm, StockObjectDrawerPlacementForm, SocietySettingsForm,
    StockObjectKindForm, ObjectUserForm, UserCreateForm, UserUpdateForm
)
from .models import (
    Society, SocietyUser, StockObjectKind, StockObject, Drawer, 
    StockObjectDrawerPlacement, StockMovement, ObjectUser, StockUsage, RefillSchedule
)


def get_user_society(user):
    """Get the primary society for a user"""
    society_user = SocietyUser.objects.filter(user=user).first()
    return society_user.society if society_user else None


def is_society_admin(user, society=None):
    """Check if user is admin for a society"""
    if society:
        return SocietyUser.objects.filter(user=user, society=society, is_society_admin=True).exists()
    return SocietyUser.objects.filter(user=user, is_society_admin=True).exists()


class SocietyAdminRequiredMixin(LoginRequiredMixin, UserPassesTestMixin):
    login_url = reverse_lazy('stock_service:custom_login_stock_service')

    def test_func(self):
        return self.request.user.is_authenticated and is_society_admin(self.request.user)

    def get_society(self):
        return get_user_society(self.request.user)


class UserManagementMixin(SocietyAdminRequiredMixin):
    def get_queryset(self):
        society = self.get_society()
        if society:
            return SocietyUser.objects.filter(society=society).select_related('user')
        return SocietyUser.objects.none()

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        society = self.get_society()
        
        if society:
            society_users = SocietyUser.objects.filter(society=society)
            context['total_users_count'] = society_users.count()
            context['admin_users_count'] = society_users.filter(is_society_admin=True).count()
            context['max_admins'] = society.get_max_admins()
            context['max_users'] = society.get_max_users()
            context['current_society_subscription_display'] = society.get_subscription_level_display()
            context['society'] = society
        else:
            context['total_users_count'] = 0
            context['admin_users_count'] = 0
            context['max_admins'] = 0
            context['max_users'] = 0
            context['current_society_subscription_display'] = _("N/A")

        return context


class UserListView(UserManagementMixin, ListView):
    model = SocietyUser
    template_name = 'stock_service/user_list.html'
    context_object_name = 'society_users'
    paginate_by = 20

    def get_queryset(self):
        society = self.get_society()
        if society:
            return SocietyUser.objects.filter(society=society).select_related('user').order_by('user__username')
        return SocietyUser.objects.none()


class UserCreateView(SocietyAdminRequiredMixin, CreateView):
    model = User
    form_class = UserCreateForm
    template_name = 'stock_service/user_form.html'
    success_url = reverse_lazy('stock_service:user_list')

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.get_society()
        return kwargs

    def form_valid(self, form):
        response = super().form_valid(form)
        new_user = self.object
        messages.success(
            self.request, 
            _("User '%(username)s' created successfully.") % {'username': new_user.username}
        )
        return response

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = _("Add New User")
        return context


class UserUpdateView(SocietyAdminRequiredMixin, UpdateView):
    model = User
    form_class = UserUpdateForm
    template_name = 'stock_service/user_form.html'
    success_url = reverse_lazy('stock_service:user_list')
    context_object_name = 'user_obj'

    def get_queryset(self):
        society = self.get_society()
        if society:
            return User.objects.filter(society_memberships__society=society)
        return User.objects.none()

    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.get_society()
        
        society_user = SocietyUser.objects.filter(
            user=self.object,
            society=self.get_society()
        ).first()
        if society_user:
            kwargs['original_is_society_admin'] = society_user.is_society_admin
        
        return kwargs

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = _("Edit User")
        context['stock_usages'] = StockUsage.objects.filter(logged_by=self.object).order_by('-start_date')[:10]
        context['show_usage_history'] = True
        return context

    def form_valid(self, form):
        messages.success(
            self.request,
            _("User '%(username)s' updated successfully.") % {'username': form.instance.username}
        )
        return super().form_valid(form)


class UserDeleteView(SocietyAdminRequiredMixin, DeleteView):
    model = User
    template_name = 'stock_service/user_confirm_delete.html'
    success_url = reverse_lazy('stock_service:user_list')
    context_object_name = 'user_obj'

    def get_queryset(self):
        society = self.get_society()
        if society:
            return User.objects.filter(society_memberships__society=society)
        return User.objects.none()

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        username = self.object.username
        response = super().post(request, *args, **kwargs)
        messages.success(
            self.request,
            _("User '%(username)s' deleted successfully.") % {'username': username}
        )
        return response


def register_society_stock_service(request):
    if request.method == 'POST':
        form = SocietyRegistrationForm(request.POST)
        if form.is_valid():
            with transaction.atomic():
                society = form.save()
                messages.success(
                    request,
                    _('Society "%(name)s" registered successfully.') % {'name': society.name}
                )
                return redirect(reverse('stock_service:custom_login_stock_service'))
        else:
            messages.error(request, _('Society registration failed. Please check the form.'))
    else:
        form = SocietyRegistrationForm()
    
    return render(
        request,
        'stock_service/register_society.html',
        {'form': form, 'title': _('Register New Society')}
    )


def custom_login_stock_service(request):
    if request.user.is_authenticated:
        return redirect(reverse('stock_service:app_home_stock_service'))

    if request.method == 'POST':
        form = CustomAuthenticationForm(request, data=request.POST)
        if form.is_valid():
            society_name = form.cleaned_data.get('society_name')
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')

            user = authenticate(
                request,
                username=username,
                password=password,
                society_name=society_name
            )

            if user is not None:
                login(request, user)
                
                try:
                    society = Society.objects.get(name=society_name)
                    request.session['society_id'] = str(society.id)
                except Society.DoesNotExist:
                    pass
                
                messages.success(request, _('Welcome, %(username)s!') % {'username': user.username})
                return redirect(reverse('stock_service:app_home_stock_service'))
            else:
                messages.error(request, _('Invalid username, password, or society.'))
        else:
            for field_name, errors in form.errors.items():
                for error in errors:
                    label = form.fields[field_name].label if field_name in form.fields else field_name
                    messages.error(request, f"{label}: {error}")
    else:
        form = CustomAuthenticationForm()

    return render(
        request,
        'stock_service/custom_login.html',
        {'form': form, 'title': _('Login')}
    )


@login_required(login_url='stock_service:custom_login_stock_service')
def user_profile_view(request):
    user = request.user
    society = get_user_society(user)

    context = {
        'title': 'プロフィール',
        'user': user,
        'user_info': {
            'username': user.username,
            'email': user.email,
            'first_name': user.first_name,
            'last_name': user.last_name,
            'date_joined': user.date_joined,
            'last_login': user.last_login,
            'is_active': user.is_active,
            'is_staff': user.is_staff,
            'is_superuser': user.is_superuser,
        }
    }

    if society:
        context['society_info'] = {
            'name': society.name,
            'can_manage_drawers': society.can_manage_drawers,
            'is_society_admin': is_society_admin(user, society),
        }

    return render(request, 'stock_service/user_profile.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def custom_logout_stock_service(request):
    logout(request)
    messages.info(request, _('Logged out successfully.'))
    return redirect(reverse('stock_service:custom_login_stock_service'))


@login_required(login_url='stock_service:custom_login_stock_service')
def app_home_stock_service(request):
    society = get_user_society(request.user)
    
    if not society:
        messages.error(request, _("Your account is not associated with a society. Contact an administrator."))
        logout(request)
        return redirect('stock_service:custom_login_stock_service')

    total_stock_objects = StockObject.objects.filter(society=society).count()
    low_stock_objects = StockObject.objects.filter(
        society=society,
        current_quantity__lt=F('minimum_quantity')
    ).count()
    recent_movements = StockMovement.objects.filter(society=society).order_by('-timestamp')[:5]
    upcoming_refills = RefillSchedule.objects.filter(
        society=society,
        is_completed=False,
        scheduled_date__gte=date.today()
    ).order_by('scheduled_date')[:5]

    context = {
        'society': society,
        'total_stock_objects': total_stock_objects,
        'low_stock_objects': low_stock_objects,
        'recent_movements': recent_movements,
        'upcoming_refills': upcoming_refills,
        'title': _('Dashboard')
    }
    return render(request, 'stock_service/app_home.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def stock_object_list_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    stock_objects = StockObject.objects.filter(society=society).order_by('name')

    if society.can_manage_drawers and society.shows_drawers_in_list:
        for obj in stock_objects:
            obj.drawer_info = obj.drawer_placements.select_related('drawer').all()

    context = {
        'stock_objects': stock_objects,
        'society': society,
        'title': _('Stock Object List'),
        'can_manage_drawers': society.can_manage_drawers,
        'shows_drawers_in_list': society.shows_drawers_in_list,
    }
    return render(request, 'stock_service/stock_object_list.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def stock_object_detail_stock_service(request, pk):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    stock_object = get_object_or_404(StockObject, pk=pk, society=society)
    movements = StockMovement.objects.filter(stock_object=stock_object).order_by('-timestamp')[:10]
    usages = StockUsage.objects.filter(stock_object=stock_object).order_by('-start_date')[:10]
    refills = RefillSchedule.objects.filter(stock_object=stock_object).order_by('scheduled_date')[:10]

    drawer_placements = None
    if society.can_manage_drawers:
        drawer_placements = StockObjectDrawerPlacement.objects.filter(stock_object=stock_object).select_related('drawer')

    context = {
        'stock_object': stock_object,
        'movements': movements,
        'usages': usages,
        'refills': refills,
        'drawer_placements': drawer_placements,
        'society': society,
        'title': _('%(object_name)s Details') % {'object_name': stock_object.name}
    }
    return render(request, 'stock_service/stock_object_detail.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def stock_out_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    if request.method == 'POST':
        form = StockMovementForm(request.POST, society=society)
        if form.is_valid():
            stock_movement = form.save(commit=False)
            stock_movement.society = society
            stock_movement.movement_type = 'out'
            stock_movement.moved_by = request.user

            stock_object = stock_movement.stock_object
            quantity = stock_movement.quantity
            drawer_involved = stock_movement.drawer_involved

            if stock_object.current_quantity >= quantity:
                with transaction.atomic():
                    stock_object.current_quantity -= quantity
                    stock_object.save()

                    if society.can_manage_drawers and drawer_involved:
                        placement, created = StockObjectDrawerPlacement.objects.get_or_create(
                            stock_object=stock_object,
                            drawer=drawer_involved,
                            defaults={'quantity': 0}
                        )
                        if placement.quantity >= quantity:
                            placement.quantity -= quantity
                            placement.save()
                        else:
                            transaction.set_rollback(True)
                            messages.error(request, _('Insufficient quantity in the specified drawer.'))
                            return render(request, 'stock_service/stock_out.html', {'form': form, 'title': _('Stock Out')})

                    stock_movement.save()
                    messages.success(request, _('%(quantity)s of %(stock_object_name)s checked out.') % {'quantity': quantity, 'stock_object_name': stock_object.name})
                    if society.can_manage_drawers and stock_movement.drawer_involved:
                         messages.info(request, _('From drawer: %(drawer)s') % {'drawer': stock_movement.drawer_involved})
                    return redirect(reverse('stock_service:stock_movement_log_stock_service'))
            else:
                messages.error(request, _('Quantity exceeds current stock. Current: %(current)s') % {'current': stock_object.current_quantity})
        else:
            messages.error(request, _('Failed to record stock out.'))
    else:
        form = StockMovementForm(society=society)
    return render(request, 'stock_service/stock_out.html', {'form': form, 'title': _('Stock Out')})


@login_required(login_url='stock_service:custom_login_stock_service')
def stock_in_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    if request.method == 'POST':
        form = StockMovementForm(request.POST, society=society)
        if form.is_valid():
            stock_movement = form.save(commit=False)
            stock_movement.society = society
            stock_movement.movement_type = 'in'
            stock_movement.moved_by = request.user

            stock_object = stock_movement.stock_object
            quantity = stock_movement.quantity
            drawer_involved = stock_movement.drawer_involved

            with transaction.atomic():
                stock_object.current_quantity += quantity
                stock_object.save()

                if society.can_manage_drawers and drawer_involved:
                    placement, created = StockObjectDrawerPlacement.objects.get_or_create(
                        stock_object=stock_object,
                        drawer=drawer_involved,
                        defaults={'quantity': 0}
                    )
                    placement.quantity += quantity
                    placement.save()

                stock_movement.save()
                messages.success(request, _('%(quantity)s of %(stock_object_name)s checked in.') % {'quantity': quantity, 'stock_object_name': stock_object.name})
                if society.can_manage_drawers and stock_movement.drawer_involved:
                     messages.info(request, _('To drawer: %(drawer)s') % {'drawer': stock_movement.drawer_involved})
                return redirect(reverse('stock_service:stock_movement_log_stock_service'))
        else:
            messages.error(request, _('Failed to record stock in.'))
    else:
        form = StockMovementForm(society=society)
    return render(request, 'stock_service/stock_in.html', {'form': form, 'title': _('Stock In')})


@login_required(login_url='stock_service:custom_login_stock_service')
def stock_movement_log_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    movements = StockMovement.objects.filter(society=society).order_by('-timestamp')
    context = {
        'movements': movements,
        'title': _('Stock Movement Log'),
    }
    return render(request, 'stock_service/stock_movement_log.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def object_user_usage_log_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    usages = StockUsage.objects.filter(society=society).order_by('-logged_at')
    context = {
        'usages': usages,
        'title': _('Object User Usage Log'),
    }
    return render(request, 'stock_service/object_user_usage_log.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def add_stock_usage_stock_service(request):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    if request.method == 'POST':
        form = StockUsageForm(request.POST, society=society)
        if form.is_valid():
            stock_usage = form.save(commit=False)
            stock_usage.society = society
            stock_usage.logged_by = request.user

            with transaction.atomic():
                stock_object = stock_usage.stock_object
                if stock_object.current_quantity >= stock_usage.quantity_used:
                    stock_object.current_quantity -= stock_usage.quantity_used
                    stock_object.save()
                    stock_usage.save()
                    messages.success(request, _('%(quantity)s of %(stock_object_name)s usage recorded.') % {'quantity': stock_usage.quantity_used, 'stock_object_name': stock_object.name})
                    return redirect(reverse('stock_service:object_user_usage_log_stock_service'))
                else:
                    messages.error(request, _('Quantity exceeds current stock. Current: %(current)s') % {'current': stock_object.current_quantity})
        else:
            messages.error(request, _('Failed to record usage.'))
    else:
        form = StockUsageForm(society=society)
    context = {
        'form': form,
        'title': _('Record Usage'),
    }
    return render(request, 'stock_service/add_stock_usage.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def refill_prediction_stock_service(request, stock_object_pk=None):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    predictions_list = []

    for stock_object_item in StockObject.objects.filter(society=society, is_active=True).order_by('name'):
        ninety_days_ago = date.today() - timedelta(days=90)
        total_used_in_90_days = StockUsage.objects.filter(
            society=society,
            stock_object=stock_object_item,
            logged_at__gte=ninety_days_ago
        ).aggregate(total_quantity=Sum('quantity_used'))['total_quantity'] or 0

        predicted_refill_date = _('Insufficient data')
        daily_usage = 0
        days_until_empty = float('inf')
        alert_message = None

        if total_used_in_90_days > 0:
            daily_usage = total_used_in_90_days / 90.0

            if daily_usage > 0:
                if stock_object_item.current_quantity > 0:
                    days_until_empty = stock_object_item.current_quantity / daily_usage
                    predicted_refill_date = date.today() + timedelta(days=int(days_until_empty))

                if stock_object_item.current_quantity <= 0:
                    predicted_refill_date = _('Immediate refill needed')
                    alert_message = _('**Out of Stock:** Immediate refill required!')
                elif days_until_empty <= 7:
                    predicted_refill_date = date.today() + timedelta(days=int(days_until_empty))
                    alert_message = _('**Urgent Refill:** Stock will run out in %s days.') % int(days_until_empty)
                elif days_until_empty <= 14:
                    predicted_refill_date = date.today() + timedelta(days=int(days_until_empty))
                    alert_message = _('**Early Refill:** Stock will run out within 2 weeks.')

            else:
                predicted_refill_date = _('No usage detected (consumption stopped)')
                if stock_object_item.current_quantity <= stock_object_item.minimum_quantity:
                    alert_message = _('**Low Stock:** Cannot predict refill due to zero consumption.')

        else:
            predicted_refill_date = _('No usage detected')

            if stock_object_item.current_quantity <= stock_object_item.minimum_quantity:
                predicted_refill_date = _('Below minimum quantity')
                alert_message = _('**Low Stock (No Usage):** No usage in 90 days but below minimum.')

        predictions_list.append({
            'stock_object': stock_object_item,
            'current_quantity': stock_object_item.current_quantity,
            'minimum_quantity': stock_object_item.minimum_quantity,
            'total_used_in_90_days': total_used_in_90_days,
            'daily_usage': f"{daily_usage:.2f}",
            'predicted_refill_date': predicted_refill_date,
            'needs_refill': stock_object_item.current_quantity <= stock_object_item.minimum_quantity,
            'alert_message': alert_message,
        })

    predictions_list.sort(key=lambda x: (
        x['alert_message'] is not None and ('Urgent' in str(x['alert_message']) or 'Out of Stock' in str(x['alert_message'])),
        x['alert_message'] is not None,
        x['needs_refill'] is True,
        isinstance(x['predicted_refill_date'], date) and x['predicted_refill_date'] or date.max,
        x['stock_object'].name
    ), reverse=True)

    context = {
        'predictions': predictions_list,
        'title': _('Refill Prediction'),
    }
    return render(request, 'stock_service/refill_prediction.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def refill_scheduler_stock_service(request, stock_object_pk=None):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    stock_object_from_url = None
    form_init_kwargs = {'society': society}

    if stock_object_pk:
        stock_object_from_url = get_object_or_404(StockObject, pk=stock_object_pk, society=society)
        form_init_kwargs['initial_stock_object'] = stock_object_from_url

    if request.method == 'POST':
        form = RefillScheduleForm(request.POST, **form_init_kwargs)
        if form.is_valid():
            refill_schedule = form.save(commit=False)
            refill_schedule.society = society
            refill_schedule.save()
            messages.success(request, _('Refill schedule created successfully.'))
            return redirect('stock_service:refill_scheduler_stock_service_general')
        else:
            messages.error(request, _('Failed to create refill schedule.'))
    else:
        form = RefillScheduleForm(**form_init_kwargs)

    existing_schedules = RefillSchedule.objects.filter(society=society).order_by('scheduled_date', 'stock_object__name')

    context = {
        'form': form,
        'stock_object': stock_object_from_url,
        'existing_schedules': existing_schedules,
        'title': _('Refill Scheduler'),
    }
    return render(request, 'stock_service/refill_scheduler.html', context)


@login_required(login_url='stock_service:custom_login_stock_service')
def complete_refill_stock_service(request, pk):
    society = get_user_society(request.user)
    if not society:
        messages.error(request, _("Society not found."))
        return redirect('stock_service:app_home_stock_service')
        
    schedule = get_object_or_404(RefillSchedule, pk=pk, society=society)

    if request.method == 'POST' and not schedule.is_completed:
        with transaction.atomic():
            schedule.is_completed = True
            schedule.completed_date = date.today()
            schedule.save()

            stock_object = schedule.stock_object
            stock_object.current_quantity += schedule.quantity_to_refill
            stock_object.save()

            StockMovement.objects.create(
                society=society,
                stock_object=stock_object,
                movement_type='in',
                quantity=schedule.quantity_to_refill,
                moved_by=request.user,
                notes=_('Auto stock-in from refill schedule (ID: %(schedule_id)s)') % {'schedule_id': schedule.pk}
            )
            messages.success(request, _('Refill completed. %(quantity)s of %(object_name)s added to stock.') % {'quantity': schedule.quantity_to_refill, 'object_name': stock_object.name})
    elif schedule.is_completed:
        messages.warning(request, _('This refill schedule is already completed.'))
    else:
        messages.error(request, _('Invalid request.'))

    return redirect(reverse('stock_service:refill_scheduler_stock_service_general'))


def get_subscription_choices():
    return Society._meta.get_field('subscription_level').choices


def pricing_stock_service(request):
    free_features = [
        _("Built-in inventory management"),
        _("User management (up to 5)"),
        _("Basic reports"),
        _("Email support (limited)"),
    ]

    basic_features = [
        _("Built-in inventory management"),
        _("User management (up to 50)"),
        _("Advanced reports"),
        _("Email & chat support"),
        _("Object user usage log"),
        _("Refill prediction"),
    ]

    premium_features = [
        _("Built-in inventory management"),
        _("Unlimited user management"),
        _("Comprehensive reports"),
        _("Email, chat & phone support"),
        _("Object user usage log"),
        _("Refill prediction"),
        _("Drawer management"),
        _("Society admin access"),
        _("Priority support"),
    ]

    current_plan_code = None
    if request.user.is_authenticated and hasattr(request.user, 'society') and request.user.society:
        request.user.refresh_from_db() # Ensure the user object and related society are fresh
        current_plan_code = request.user.society.subscription_level if hasattr(request.user, 'society') else 'free'
    context = {
        'free_features': free_features,
        'basic_features': basic_features,
        'premium_features': premium_features,

        'current_plan': current_plan_code, # Pass the plan code
        'SUBSCRIPTION_CHOICES_DICT': dict(get_subscription_choices()) # Pass for lookup in template if needed
    }
    return render(request, 'stock_service/pricing.html', context)

@login_required(login_url='stock_service:custom_login_stock_service')
def fake_payment_view(request):
    """
    A dummy view to simulate a payment page and update society's subscription.
    Handles both upgrades and downgrades.
    """
    selected_plan = request.GET.get('plan') # Get the plan from URL parameter

    # Get valid choices directly from the model field for validation
    valid_subscription_choices = [choice[0] for choice in get_subscription_choices()]

    if selected_plan in valid_subscription_choices:
        try:
            society = get_user_society(request.user)
            if not society:
                messages.error(request, _("ユーザーは社会に所属していません。"))
                return redirect(reverse('stock_service:pricing_stock_service'))

            society = get_user_society(request.user)

            # Check if the selected plan is actually a change
            if society.subscription_level != selected_plan:
                society.subscription_level = selected_plan

                # --- Downgrade/Upgrade Feature Adjustment Logic ---
                # This ensures features are automatically disabled if the new plan doesn't support them.
                if selected_plan == 'free':
                    society.can_manage_drawers = False
                    society.shows_drawers_in_list = False
                elif selected_plan == 'basic':
                    society.shows_drawers_in_list = False

                society.save()
                messages.success(request, _("プランが %(plan)s に変更されました！") % {'plan': society.get_subscription_level_display()})
            else:
                messages.info(request, _("すでに %(plan)s プランをご利用中です。") % {'plan': society.get_subscription_level_display()})

        except Exception as e:
            messages.error(request, _("プランの変更中にエラーが発生しました: %(error)s") % {'error': str(e)})
    else:
        messages.error(request, _("無効なプランが選択されました。"))

    return redirect(reverse('stock_service:pricing_stock_service')) # Redirect will cause a fresh request and user object reload
    # Added refresh_from_db() to pricing_view directly to ensure it gets the latest data.


@login_required(login_url='stock_service:custom_login_stock_service')
def society_settings_stock_service(request):
    """
    社会ごとの設定を管理するビュー。
    特に引き出し管理オプション。
    """
    society = get_user_society(request.user)
    if not request.user.is_society_admin:
        messages.error(request, _('このページにアクセスする権限がありません。'))
        return redirect(reverse('stock_service:app_home_stock_service'))

    if request.method == 'POST':
        form = SocietySettingsForm(request.POST, instance=society)
        if form.is_valid():
            form.save()
            messages.success(request, _('社会設定が正常に更新されました。'))
            return redirect(reverse('stock_service:society_settings_stock_service'))
        else:
            messages.error(request, _('社会設定の更新に失敗しました。フォームの入力内容を確認してください。'))
    else:
        form = SocietySettingsForm(instance=society)

    context = {
        'form': form,
        'title': _('社会設定'),
        'society': society,
        'current_subscription_plan': society.get_subscription_level_display(), # Human-readable plan name
        'subscription_code': society.subscription_level, # The code ('free', 'basic', 'premium')
    }
    return render(request, 'stock_service/society_settings.html', context)

class DrawerManagementMixin(LoginRequiredMixin, UserPassesTestMixin):
    """
    Mixin to ensure user is logged in and is a society admin.
    Also checks if drawer management is enabled for the society.
    Ensures actions are within their society.
    """
    login_url = reverse_lazy('stock_service:custom_login_stock_service')

    def test_func(self):
        # 社会管理者であり、かつ引き出し管理が有効な社会に属している場合にアクセスを許可
        if not self.request.user.is_authenticated or not self.request.user.is_society_admin:
            return False

        # Societyにcan_manage_drawersが設定されているか確認
        if not hasattr(self.request.user, 'society') or not self.request.user.society:
            messages.error(self.request, _("社会情報が見つかりません。"))
            return False

        if not self.request.user.society.can_manage_drawers:
            messages.warning(self.request, _('この社会では引き出し管理機能が有効になっていません。'))
            return False
        return True

    def get_queryset(self):
        # 現在の社会に属するDrawerのみをクエリ
        if self.request.user.is_authenticated and self.request.user.society:
            return Drawer.objects.filter(society=self.request.user.society).order_by('cabinet_name', 'drawer_letter_x', 'drawer_number_y')
        return Drawer.objects.none() # 権限がない場合は空のクエリセットを返す


# 既存の関数ベースビュー manage_drawers_stock_service は、リスト表示と新規作成フォームのみを扱います。
@login_required(login_url='stock_service:custom_login_stock_service')
def manage_drawers_stock_service(request):
    """
    引き出しのリストを表示し、新しい引き出しを追加するビュー。
    """
    society = request.user.society
    if not society.can_manage_drawers:
        messages.warning(request, _('この社会では引き出し管理機能が有効になっていません。'))
        return redirect(reverse('stock_service:app_home_stock_service'))

    drawers = Drawer.objects.filter(society=society).order_by('cabinet_name', 'drawer_letter_x', 'drawer_number_y')

    if request.method == 'POST':
        # フォームに society を渡す
        form = DrawerForm(request.POST, society=society)
        if form.is_valid():
            drawer = form.save(commit=False)
            drawer.society = society
            drawer.save()
            messages.success(request, _('引き出し "%(drawer_name)s" が追加されました。') % {'drawer_name': drawer.__str__()})
            return redirect(reverse('stock_service:manage_drawers_stock_service'))
        else:
            messages.error(request, _('引き出しの追加に失敗しました。フォームの入力内容を確認してください。'))
    else:
        # フォームに society を渡す
        form = DrawerForm(society=society)

    context = {
        'drawers': drawers,
        'form': form,
        'title': _('引き出しの管理'),
        'can_manage_drawers': society.can_manage_drawers,
    }
    return render(request, 'stock_service/manage_drawers.html', context)


class DrawerUpdateView(DrawerManagementMixin, UpdateView):
    model = Drawer
    form_class = DrawerForm
    template_name = 'stock_service/drawer_form.html' # 新しいフォームテンプレート
    context_object_name = 'drawer_obj' # テンプレートでの変数名
    success_url = reverse_lazy('stock_service:manage_drawers_stock_service')

    def get_form_kwargs(self):
        # フォームに society インスタンスを渡す
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.request.user.society
        return kwargs

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = _("引き出しを編集")
        return context

    def form_valid(self, form):
        messages.success(self.request, _("引き出し '%(drawer_name)s' が正常に更新されました。") % {'drawer_name': form.instance.__str__()})
        return super().form_valid(form)


class DrawerDeleteView(DrawerManagementMixin, DeleteView):
    model = Drawer
    template_name = 'stock_service/drawer_confirm_delete.html' # 新しい削除確認テンプレート
    context_object_name = 'drawer_obj' # テンプレートでの変数名
    success_url = reverse_lazy('stock_service:manage_drawers_stock_service')

    def form_valid(self, form):
        messages.success(self.request, _("引き出し '%(drawer_name)s' が正常に削除されました。") % {'drawer_name': self.object.__str__()})
        return super().form_valid(form)

@login_required(login_url='stock_service:custom_login_stock_service')
def assign_stock_to_drawer_stock_service(request):
    """
    在庫品目を引き出しに割り当てるビュー。
    """
    society = request.user.society
    if not society.can_manage_drawers:
        messages.warning(request, _('この社会では引き出し管理機能が有効になっていません。'))
        return redirect(reverse('stock_service:app_home_stock_service'))

    if request.method == 'POST':
        form = StockObjectDrawerPlacementForm(request.POST, society=society)
        if form.is_valid():
            placement = form.save(commit=False)
            placement.save() # societyはモデルに直接紐づいていないが、フォームでフィルタリングされている
            messages.success(request, _('%(stock_object)s が %(drawer)s に割り当てられました。') % {'stock_object': placement.stock_object.name, 'drawer': placement.drawer.__str__()})
            return redirect(reverse('stock_service:stock_object_detail_stock_service', args=[placement.stock_object.pk]))
        else:
            messages.error(request, _('在庫品目の引き出しへの割り当てに失敗しました。フォームの入力内容を確認してください。'))
    else:
        form = StockObjectDrawerPlacementForm(society=society)

    context = {
        'form': form,
        'title': _('引き出しに在庫を割り当てる'),
    }
    return render(request, 'stock_service/assign_stock_to_drawer.html', context)

class StockObjectKindManagementMixin(LoginRequiredMixin, UserPassesTestMixin):
    """
    Mixin to ensure user is logged in and is a society admin.
    Ensures actions are within their society.
    """
    login_url = reverse_lazy('stock_service:custom_login_stock_service')

    def test_func(self):
        # 社会管理者のみがアクセスできる
        return self.request.user.is_authenticated and self.request.user.is_society_admin

    def get_queryset(self):
        # 現在の社会に属するStockObjectKindのみをクエリ
        if self.request.user.is_authenticated and self.request.user.is_society_admin:
            return StockObjectKind.objects.filter(society=self.request.user.society).order_by('name')
        return StockObjectKind.objects.none() # 権限がない場合は空のクエリセットを返す

@login_required(login_url='stock_service:custom_login_stock_service')
def stock_object_kind_list_stock_service(request):
    """
    在庫品目の種類のリストを表示・管理するビュー。
    新しい種類の追加もここで行う。
    """
    society = request.user.society
    kinds = StockObjectKind.objects.filter(society=society).order_by('name')

    if request.method == 'POST':
        # フォームにsocietyを渡す
        form = StockObjectKindForm(request.POST, society=society)
        if form.is_valid():
            kind = form.save(commit=False)
            kind.society = society
            kind.save()
            messages.success(request, _('在庫品目の種類 "%(name)s" が追加されました。') % {'name': kind.name})
            return redirect(reverse('stock_service:stock_object_kind_list_stock_service'))
        else:
            messages.error(request, _('在庫品目の種類の追加に失敗しました。フォームの入力内容を確認してください。'))
    else:
        # フォームにsocietyを渡す
        form = StockObjectKindForm(society=society)

    context = {
        'kinds': kinds,
        'form': form,
        'title': _('在庫品目の種類の管理'),
    }
    return render(request, 'stock_service/stock_object_kind_list.html', context)

class StockObjectKindUpdateView(StockObjectKindManagementMixin, UpdateView):
    model = StockObjectKind
    form_class = StockObjectKindForm
    template_name = 'stock_service/stock_object_kind_form.html' # 新しいフォームテンプレート
    context_object_name = 'kind_obj' # テンプレートでの変数名
    success_url = reverse_lazy('stock_service:stock_object_kind_list_stock_service')

    def get_form_kwargs(self):
        # フォームに society インスタンスを渡す
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.request.user.society
        return kwargs

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = _("在庫品目の種類を編集")
        return context

    def form_valid(self, form):
        messages.success(self.request, _("在庫品目の種類 '%(name)s' が正常に更新されました。") % {'name': form.instance.name})
        return super().form_valid(form)


class StockObjectKindDeleteView(StockObjectKindManagementMixin, DeleteView):
    model = StockObjectKind
    template_name = 'stock_service/stock_object_kind_confirm_delete.html' # 新しい削除確認テンプレート
    context_object_name = 'kind_obj' # テンプレートでの変数名
    success_url = reverse_lazy('stock_service:stock_object_kind_list_stock_service')

    def form_valid(self, form):
        messages.success(self.request, _("在庫品目の種類 '%(name)s' が正常に削除されました。") % {'name': self.object.name})
        return super().form_valid(form)

@login_required(login_url='stock_service:custom_login_stock_service')
def add_stock_object_stock_service(request):
    """
    新しい在庫品目を追加するビュー。
    """
    society = request.user.society
    if request.method == 'POST':
        form = StockObjectForm(request.POST, society=society)
        if form.is_valid():
            stock_object = form.save(commit=False)
            stock_object.society = society
            stock_object.save()
            messages.success(request, _('新しい在庫品目 "%(name)s" が追加されました。') % {'name': stock_object.name})
            return redirect(reverse('stock_service:stock_object_list_stock_service'))
        else:
            messages.error(request, _('在庫品目の追加に失敗しました。フォームの入力内容を確認してください。'))
    else:
        form = StockObjectForm(society=society)

    context = {
        'form': form,
        'title': _('新しい在庫品目を追加'),
    }
    return render(request, 'stock_service/add_stock_object.html', context)

@login_required(login_url='stock_service:custom_login_stock_service')
def update_stock_object_stock_service(request, pk):
    """
    既存の在庫品目を更新するビュー。
    """
    society = request.user.society
    stock_object = get_object_or_404(StockObject, pk=pk, society=society)

    if request.method == 'POST':
        form = StockObjectForm(request.POST, instance=stock_object, society=society)
        if form.is_valid():
            form.save()
            messages.success(request, _('在庫品目 "%(name)s" が更新されました。') % {'name': stock_object.name})
            return redirect(reverse('stock_service:stock_object_detail_stock_service', args=[pk]))
        else:
            messages.error(request, _('在庫品目の更新に失敗しました。フォームの入力内容を確認してください。'))
    else:
        form = StockObjectForm(instance=stock_object, society=society)

    context = {
        'form': form,
        'stock_object': stock_object,
        'title': _('%(name)s を更新') % {'name': stock_object.name},
    }
    return render(request, 'stock_service/update_stock_object.html', context)

@login_required(login_url='stock_service:custom_login_stock_service')
def delete_stock_object_stock_service(request, pk):
    """
    在庫品目を削除するビュー。
    """
    society = request.user.society
    stock_object = get_object_or_404(StockObject, pk=pk, society=society)

    if request.method == 'POST':
        stock_object.delete()
        messages.success(request, _('在庫品目 "%(name)s" が削除されました。') % {'name': stock_object.name})
        return redirect(reverse('stock_service:stock_object_list_stock_service'))

    context = {
        'stock_object': stock_object,
        'title': _('%(name)s を削除') % {'name': stock_object.name},
    }
    return render(request, 'stock_service/confirm_delete.html', context)



class ObjectUserManagementMixin(LoginRequiredMixin, UserPassesTestMixin):
    """
    Mixin to ensure user is logged in and is a society admin.
    Also ensures actions are within their society.
    """
    login_url = reverse_lazy('stock_service:custom_login_stock_service')

    def test_func(self):
        # 社会管理者のみがアクセスできる
        return self.request.user.is_authenticated and self.request.user.is_society_admin

    def get_queryset(self):
        # 現在の社会に属するObjectUserのみをクエリ
        if self.request.user.is_authenticated and self.request.user.is_society_admin:
            return ObjectUser.objects.filter(society=self.request.user.society).order_by('name')
        return ObjectUser.objects.none() # 権限がない場合は空のクエリセットを返す

class ObjectUserListView(ObjectUserManagementMixin, ListView):
    model = ObjectUser
    template_name = 'stock_service/objectuser_list.html'
    context_object_name = 'object_users'
    paginate_by = 20 # 任意でページネーションを設定


class ObjectUserCreateView(ObjectUserManagementMixin, CreateView):
    model = ObjectUser
    form_class = ObjectUserForm
    template_name = 'stock_service/objectuser_form.html'
    success_url = reverse_lazy('stock_service:objectuser_list')

    def get_form_kwargs(self):
        # フォームに society インスタンスを渡す
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.request.user.society # <-- This line is crucial and correct
        return kwargs

    def form_valid(self, form):
        # form.instance の society フィールドを自動的に設定
        form.instance.society = self.request.user.society
        messages.success(self.request, _("オブジェクトユーザー '%(name)s' が正常に作成されました。") % {'name': form.instance.name})
        return super().form_valid(form)


class ObjectUserUpdateView(ObjectUserManagementMixin, UpdateView):
    model = ObjectUser
    form_class = ObjectUserForm
    template_name = 'stock_service/objectuser_form.html'
    success_url = reverse_lazy('stock_service:objectuser_list')
    context_object_name = 'objectuser_obj' # テンプレートでの変数名

    def get_form_kwargs(self):
        # フォームに society インスタンスを渡す (更新時も必要)
        kwargs = super().get_form_kwargs()
        kwargs['society'] = self.request.user.society # <-- This line is crucial and correct
        return kwargs


class ObjectUserDeleteView(ObjectUserManagementMixin, DeleteView):
    model = ObjectUser
    template_name = 'stock_service/objectuser_confirm_delete.html'
    success_url = reverse_lazy('stock_service:objectuser_list')
    context_object_name = 'objectuser_obj'

    def form_valid(self, form):
        messages.success(self.request, _("オブジェクトユーザー '%(name)s' が正常に削除されました。") % {'name': self.object.name})
        return super().form_valid(form)
